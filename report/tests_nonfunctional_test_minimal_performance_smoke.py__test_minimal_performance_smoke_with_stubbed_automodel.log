monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x70a1fa9fbfd0&gt;

    @pytest.mark.nonfunctional
    @pytest.mark.slow
    def test_minimal_performance_smoke_with_stubbed_automodel(monkeypatch):
        &quot;&quot;&quot;run_loto_experiment が小規模設定で一定時間内に完了することをスモーク確認。
    
        - 実際の NeuralForecast AutoModel は heavy なので、テストでは build_auto_model と
          build_neuralforecast をスタブして高速化している。
        - DB アクセスも避けるため、loto_repository.load_panel_by_loto をスタブして
          100 × 30 日程度の極小パネルを返す。
        &quot;&quot;&quot;
    
        from nf_loto_platform.db import loto_repository  # import here for monkeypatch target
    
        H = 7  # 1 週間先までの予測
        unique_ids = [f&quot;series_{i}&quot; for i in range(10)]
        dates = pd.date_range(&quot;2024-01-01&quot;, periods=30, freq=&quot;D&quot;)
        records = []
        for uid in unique_ids:
            y = np.random.randn(len(dates))
            for ds, val in zip(dates, y):
                records.append({&quot;unique_id&quot;: uid, &quot;ds&quot;: ds, &quot;y&quot;: float(val)})
        panel_df = pd.DataFrame.from_records(records)
    
        # --- DB リポジトリのスタブ ---
        def _fake_load_panel_by_loto(table_name: str, loto: str, **kwargs):
            # 引数がちゃんと渡っていることをざっくり確認
            assert table_name == &quot;nf_loto_panel&quot;
            unique_ids_arg = kwargs.get(&quot;unique_ids&quot;)
            assert set(unique_ids_arg) == set(unique_ids)
            return panel_df
    
        monkeypatch.setattr(
            &quot;nf_loto_platform.ml.model_runner.load_panel_by_loto&quot;,
            _fake_load_panel_by_loto,
        )
    
        # --- AutoModel / NeuralForecast のスタブ ---
        def _fake_build_auto_model(
            model_name: str,
            backend: str,
            h: int,
            loss_name: str,
            num_samples: int,
            search_space=None,
            early_stop=None,
            early_stop_patience_steps: int = 3,
            verbose: bool = True,
        ):
            # 引数がそれなりに渡っていることだけ確認して dummy を返す
            assert h == H
            assert num_samples == 1
            return _DummyAutoModel(h=h)
    
        def _fake_build_neuralforecast(model, freq: str, local_scaler_type: str | None):
            # 本来は NeuralForecast インスタンスを作るが、ここではそのまま model を返す
            return model
    
        monkeypatch.setattr(
            &quot;nf_loto_platform.ml.automodel_builder.build_auto_model&quot;,
            _fake_build_auto_model,
        )
        monkeypatch.setattr(
            &quot;nf_loto_platform.ml.automodel_builder.build_neuralforecast&quot;,
            _fake_build_neuralforecast,
        )
    
        # --- 実行 &amp; 時間計測 ---
        start = time.perf_counter()
&gt;       preds, meta = run_loto_experiment(
            table_name=&quot;nf_loto_panel&quot;,
            loto=&quot;loto6&quot;,
            unique_ids=unique_ids,
            model_name=&quot;AutoNHITS&quot;,
            backend=&quot;local&quot;,
            horizon=H,
            loss=&quot;mae&quot;,
            metric=&quot;mae&quot;,
            num_samples=1,
            cpus=1,
            gpus=0,
            search_space=None,
            freq=&quot;D&quot;,
            local_scaler_type=&quot;robust&quot;,
            val_size=7,
            refit_with_val=False,
            use_init_models=False,
            early_stop=True,
            early_stop_patience_steps=1,
        )

tests/nonfunctional/test_minimal_performance_smoke.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

table_name = &#x27;nf_loto_panel&#x27;, loto = &#x27;loto6&#x27;, unique_ids = [&#x27;series_0&#x27;, &#x27;series_1&#x27;, &#x27;series_2&#x27;, &#x27;series_3&#x27;, &#x27;series_4&#x27;, &#x27;series_5&#x27;, ...], model_name = &#x27;AutoNHITS&#x27;
backend = &#x27;local&#x27;, horizon = 7, loss = &#x27;mae&#x27;, metric = &#x27;mae&#x27;, num_samples = 1, cpus = 1, gpus = 0, search_space = None, freq = &#x27;D&#x27;, local_scaler_type = &#x27;robust&#x27;, val_size = 7
refit_with_val = False, use_init_models = False, early_stop = True, early_stop_patience_steps = 1

    def run_loto_experiment(
        table_name: str,
        loto: str,
        unique_ids: Sequence[str],
        model_name: str,
        backend: str,
        horizon: int,
        loss: str,
        metric: str,
        num_samples: int,
        cpus: int = 1,
        gpus: int = 0,
        search_space: Optional[Dict[str, Any]] = None,
        freq: str = &quot;D&quot;,
        local_scaler_type: Optional[str] = &quot;robust&quot;,
        val_size: Optional[int] = None,
        refit_with_val: bool = True,
        use_init_models: bool = False,
        early_stop: Optional[bool] = True,
        early_stop_patience_steps: int = 3,
    ) -&gt; Tuple[pd.DataFrame, Dict[str, Any]]:
        &quot;&quot;&quot;単一設定で AutoModel 実験を 1 回実行し、予測結果とメタ情報を返す。
    
        verbose=True / loss==valid_loss は automodel_builder 側で設定。
        &quot;&quot;&quot;
        start_ts = time.time()
        # Prometheus metrics サーバを必要に応じて起動 (複数回呼ばれても安全)
        try:
            init_metrics_server(port=int(os.getenv(&quot;NF_METRICS_PORT&quot;, &quot;8000&quot;)))
        except Exception:  # noqa: BLE001
            # 監視系の初期化失敗で実験本体が落ちないようにする
            pass
    
        start_resources = collect_resource_snapshot()
        system_info = _system_info()
    
        optimization_config = {
            &quot;backend&quot;: backend,
            &quot;num_samples&quot;: num_samples,
            &quot;cpus&quot;: cpus,
            &quot;gpus&quot;: gpus,
            &quot;val_size&quot;: val_size,
            &quot;refit_with_val&quot;: refit_with_val,
            &quot;use_init_models&quot;: use_init_models,
            &quot;early_stop&quot;: early_stop,
            &quot;early_stop_patience_steps&quot;: early_stop_patience_steps,
        }
    
        run_id = log_run_start(
            table_name=table_name,
            loto=loto,
            unique_ids=unique_ids,
            model_name=model_name,
            backend=backend,
            horizon=horizon,
            loss=loss,
            metric=metric,
            optimization_config=optimization_config,
            search_space=search_space or {},
            resource_snapshot=start_resources,
            system_info=system_info,
        )
    
        # Prometheus: 実行開始を通知
        observe_run_start(model_name=model_name, backend=backend)
    
        try:
            panel_df = load_panel_by_loto(table_name=table_name, loto=loto, unique_ids=unique_ids)
            df, futr_exog_list, hist_exog_list, stat_exog_list = _prepare_dataset(panel_df)
    
            model = build_auto_model(
                model_name=model_name,
                backend=backend,
                h=horizon,
                loss_name=loss,
                num_samples=num_samples,
                search_space=search_space,
                early_stop=early_stop,
                early_stop_patience_steps=early_stop_patience_steps,
                verbose=True,
            )
    
            nf = build_neuralforecast(
                model=model,
                freq=freq,
                local_scaler_type=local_scaler_type,
            )
    
            # fit
&gt;           nf.fit(
                df=df,
                futr_exog_list=futr_exog_list,
                hist_exog_list=hist_exog_list,
                stat_exog_list=stat_exog_list,
                verbose=True,
            )
E           TypeError: NeuralForecast.fit() got an unexpected keyword argument &#x27;futr_exog_list&#x27;

src/nf_loto_platform/ml/model_runner.py:208: TypeError

------------------------------ Captured log call -------------------------------
ERROR    nf_loto_platform.monitoring.prometheus_metrics:prometheus_metrics.py:64 Failed to start Prometheus metrics server.
Traceback (most recent call last):
  File &quot;/mnt/e/env/ts/nf/nf_ws/src/nf_loto_platform/monitoring/prometheus_metrics.py&quot;, line 60, in init_metrics_server
    start_http_server(port)  # type: ignore[call-arg]
    ^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/site-packages/prometheus_client/exposition.py&quot;, line 241, in start_wsgi_server
    httpd = make_server(addr, port, app, TmpServer, handler_class=_SilentHandler)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/wsgiref/simple_server.py&quot;, line 154, in make_server
    server = server_class((host, port), handler_class)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/socketserver.py&quot;, line 456, in __init__
    self.server_bind()
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/wsgiref/simple_server.py&quot;, line 50, in server_bind
    HTTPServer.server_bind(self)
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/http/server.py&quot;, line 136, in server_bind
    socketserver.TCPServer.server_bind(self)
  File &quot;/home/az/miniconda3/envs/nc/lib/python3.11/socketserver.py&quot;, line 472, in server_bind
    self.socket.bind(self.server_address)
OSError: [Errno 98] Address already in use

